åœ¨ HM ç±»å‹ç³»ç»Ÿå®šä¹‰é‡Œï¼Œğœ è¢«ç§°åšç±»å‹ï¼ˆTypeï¼‰ï¼Œå®ƒå¯ä»¥æ˜¯ä¸€ä¸ª
- åŸç”Ÿç±»å‹ Primitiveï¼šğœ„
- ç±»å‹å˜é‡ Type Variableï¼šğ›¼
- å‡½æ•°ç±»å‹ Function ï¼šğœ â†’ ğœ
- (è¿™é‡ŒåŠ å…¥äº† RecordType, æ–¹ä¾¿æ¼”ç¤º subtyping)
è€Œ ğœ è¢«ç§°åš Type Schemeã€‚å®ƒå³å¯ä»¥æ˜¯ä¸€ä¸ª ğœï¼Œå³ typeï¼›ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ª âˆ€ğ›¼.ğœ (polymorphicType)ã€‚
polymorphicType ä¸æ˜¯ Type (simpleType)
âˆ€ æ­£æ˜¯ç±»å‹ç³»ç»Ÿé‡Œçš„ ğœ†
ä¸€ä¸ªå½¢å¦‚ âˆ€ğ›¼.ğ›¼ â†’ ğ›¼ çš„ ğœ† åœ¨ä¸åŒçš„åœ°æ–¹è¢«è°ƒç”¨ï¼ˆå®ä¾‹åŒ–ï¼‰æ—¶ï¼Œä¼šé€šè¿‡ä¼ å…¥ä¸åŒçš„ ğ›¼ è€Œå¾—åˆ°ä¸åŒçš„ç±»å‹ Type

åœ¨HMç±»å‹ç³»ç»Ÿé‡Œï¼Œæ‰€æœ‰çš„ç±»å‹å˜é‡éƒ½æ˜¯å•æ€ç±»å‹

monotype = ğœ
polytype = âˆ€ğ›¼.ğœ
ğœ = type scheme = type
ğœ = ğ›¼ | ğœ„ | ğœ â†’ ğœ
ğœ = ğœ | âˆ€ğ›¼.ğœ

lambda = ğœ†
type lambda = Î›

ğœ† 					vs 				Î›
Value								monotype
Literal Constant: 0,1,2,True,False	Primitive: Int,Bool
Variable: ğ‘¥,ğ‘¦ 						Type Variable: ğ›¼, ğ›½
Variable Binding				    Type Variable Binding
Immutable Variable					Immutable Type Variable
Function Application				Type Instantiation
Type								Kind


------------------------------------------------------------------------------------
MLsub ä¸¤ç§ç‰¹æ®Šç±»å‹
------------------------------------------------------------------------------------
1. set-theoretic types: union type and intersection type
	ğœ0 âŠ” ğœ1 represents the type of values that are either of type ğœ0 or  of type ğœ1.
	ğœ0 âŠ“ ğœ1 represents the type of values that are both   of type ğœ0 and of type ğœ1.
	union æ˜¯ æˆ–, inter æ˜¯ ä¸

MLsub ä½¿ç”¨ union å’Œ intersection ç±»å‹æ¥é—´æ¥åœ°çº¦æŸç±»å‹å˜é‡ã€‚
å½“ä¸€ä¸ªç±»å‹å˜é‡ ğ›¼ æ˜¯æŸä¸ªç±»å‹ ğœ çš„å­ç±»å‹æ—¶ï¼ˆå³ ğ›¼ ç±»å‹çš„å€¼å¯ä»¥ç”¨äº ğœ ç±»å‹ï¼‰ï¼Œ
MLsub åœ¨è¾“å…¥ä½ç½®ç”¨ ğ›¼âŠ“ğœ æ›¿æ¢æ‰€æœ‰å‡ºç°çš„ ğ›¼ï¼Œç¡®ä¿ä»»ä½•ä½œä¸º ğ›¼ å€¼ä¼ é€’è¿›æ¥çš„å‚æ•°ä¹Ÿæ˜¯ ğœ å€¼ã€‚
åŒæ ·ï¼Œå½“ ğ›¼ æ˜¯æŸä¸ªç±»å‹ ğœ çš„è¶…ç±»å‹æ—¶ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œğœ ç±»å‹çš„å€¼å¯ä»¥ç”¨äº ğ›¼ ç±»å‹ï¼‰ï¼Œ
MLsub åœ¨è¾“å‡ºä½ç½®ç”¨ ğ›¼âŠ”ğœ æ›¿æ¢æ‰€æœ‰å‡ºç°çš„ ğ›¼ ï¼Œç¡®ä¿ä½œä¸º ğ›¼ å€¼è¿”å›çš„ç»“æœä¹Ÿæ˜¯ ğœ å€¼ã€‚
e.g.
(âˆ’) :: int â†’ int â†’ int
ğœ†ğ‘¥. { L = ğ‘¥ âˆ’ 1 ; R = ğ‘¥ }  ::  ğ›¼ âŠ“ int â†’ { L : int; R : ğ›¼ }
ğœ† ğ‘“ . ğœ†ğ‘¥. { L = ğ‘“ ğ‘¥ ; R = ğ‘¥ } :: (ğ›½ â†’ ğ›¾) â†’ ğ›¼ âŠ“ ğ›½ â†’ { L : ğ›¾ ; R : ğ›¼ }
ç®€åŒ–ä¸º (ğ›¼ â†’ ğ›¾) â†’ ğ›¼ â†’ { L : ğ›¾ ; R : ğ›¼ }.

2. RecursiveType
ä¸€ä¸ªé€’å½’ç±»å‹ ğœ‡ğ›¼. ğœ ä»£è¡¨ä¸€ä¸ªæˆ‘ä»¬å¯ä»¥éšæ„å±•å¼€å¤šæ¬¡çš„ç±»å‹;
ä¾‹å¦‚ï¼Œğœ‡ğ›¼. (âŠ¤ â†’ ğ›¼)ï¼Œæˆ‘ä»¬åªå†™ ğœ‡ğ›¼. âŠ¤ â†’ ğ›¼ï¼Œç­‰åŒäº âŠ¤ â†’ ğœ‡ğ›¼. âŠ¤ â†’ ğ›¼, è¿™ç›¸å½“äºâŠ¤ â†’ âŠ¤ â†’ ğœ‡ğ›¼. âŠ¤ â†’ ğ›¼ï¼Œ...ï¼Œ
é€’å½’ç±»å‹æ˜¯å¯ä»¥æ— é™åˆ¶åº”ç”¨äºä»»ä½•å‚æ•°ï¼ˆâŠ¤çš„ä»»ä½•å­ç±»å‹ï¼‰çš„å‡½æ•°çš„ç±»å‹ã€‚
é€’å½’ç±»å‹åœ¨æ¦‚å¿µä¸Šæ˜¯æ— é™çš„ -- å¦‚æœå®Œå…¨å±•å¼€ï¼Œå®ƒå°†å±•å¼€ä¸ºä¸€ä¸ªæ— é™æ·±çš„æ ‘ âŠ¤ â†’ âŠ¤ â†’ âŠ¤ â†’ ....

------------------------------------------------------------------------------------
Polarity of Type Positions
------------------------------------------------------------------------------------
term ä½œä¸ºè¾“å…¥çš„ç±»å‹, consumer, input position, negative position/occurrence
term ä½œä¸ºè¾“å‡ºçš„ç±»å‹, provider, output position, position position/occurrence
positive occurrence ä»£è¡¨ provider: ä¸€æ®µç¨‹åº"æ„å»º"å‡ºæœ‰ positive type çš„å€¼ã€‚
negative occurrence ä»£è¡¨ consumer: ä¸€æ®µç¨‹åº"éœ€è¦"(æˆ–è€…è¯´ abstract over) æœ‰ negative type çš„å€¼ã€‚
å½“æˆ‘ä»¬æ„å»ºä¸€ä¸ªç±»å‹ä¸º A â†’ B çš„å‡½æ•°æ—¶ï¼Œè¿™ä¸ªå‡½æ•°éœ€è¦ Aï¼Œå¹¶æ„å»º Bã€‚ æ‰€ä»¥ Aâˆ’ â†’ B+ âˆˆ PosTypesã€‚
å½“æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»å‹ä¸º A â†’ B çš„å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬æ„å»º A å¹¶æä¾›ç»™å®ƒï¼Œå¹¶éœ€ è¦å®ƒè¿”å›çš„ Bã€‚æ‰€ä»¥ A+ â†’ Bâˆ’ âˆˆ NegTypesã€‚
ç±»å‹ç³»ç»Ÿä¸­å¯¹ä¸åŒè¡¨è¾¾å¼çš„ç±»å‹çš„å”¯ä¸€é™åˆ¶åº”å½“æ¥è‡ªäº provider ä¸ consumer è¿æ¥èµ·æ¥æ—¶çš„ä¸€è‡´æ€§ã€‚
æ‰€ä»¥ä½¿ç”¨ polar types çš„ç±»å‹æ¨å¯¼åªä¼šäº§ç”Ÿ å½¢å¦‚ A+ â‰¼ Aâˆ’ çš„ constraintã€‚
e.g. (ğœ0 â†’ ğœ1) â†’ ğœ2
ç±»å‹ ğœ2 å¤„äº positive positionï¼Œå› ä¸ºå®ƒæ˜¯ä¸»å‡½æ•°çš„è¾“å‡ºï¼Œ
è€Œå‡½æ•°ç±»å‹ (ğœ0 â†’ ğœ1) å¤„äº negative positionï¼Œå› ä¸ºå®ƒè¢«ä½œä¸ºä¸»å‡½æ•°è¾“å…¥ã€‚
å¦ä¸€æ–¹é¢ï¼Œ
è¢«ä½œä¸ºè¾“å…¥çš„å‡½æ•°è¿”å›çš„ ğœ1 å¤„äº negative position, å› ä¸ºå®ƒæ˜¯ç”±è°ƒç”¨è€…é€šè¿‡å‚æ•°å‡½æ•°æä¾›çš„,
è€Œ ğœ0 åˆ™å¤„äº positive position ä½ç½®, å› ä¸ºå®ƒæ˜¯ç”±ä¸»å‡½æ•°åœ¨è°ƒç”¨å‚æ•°å‡½æ•°æ—¶æä¾›çš„ã€‚
For instance, in (ğœ0 â†’ ğœ1) â†’ ğœ2, type ğœ2 is in positive position since it is the output of the main function,
and the function type (ğœ0 â†’ ğœ1) is in negative position, as it is taken as an input to the main function.
On the other hand, ğœ1, which is returned by the function taken as input is in negative position
(since it is provided by callers via the argument function),
and ğœ0 is in positive position (since it is provided by the main function when calling the argument function).

MLsub çš„ç±»å‹æ˜¯æœ‰æ­£è´ŸåŒºåˆ†çš„, ææ€§é™åˆ¶æ„å‘³ç€ unionã€intersection çš„å®Œæ•´ç±»å‹è¯­æ³•å®é™…ä¸Šä½¿ç”¨æœ‰é™åˆ¶, ä¸èƒ½å†™å‡ºè¿åææ€§åŒºåˆ†çš„ç±»å‹
union æ˜¯ positive type ä¸”ä¸èƒ½å‡ºç°åœ¨ negative position
intersection æ˜¯ negative type ä¸”ä¸èƒ½å‡ºç°åœ¨ positive position
e.g. intâŠ”string â†’ ğœ éæ³•, negative åªèƒ½å‡ºç° âŠ“ï¼Œğœ â†’ intâŠ”string åˆæ³•, ä½†æ˜¯æ²¡å•¥ç”¨

ğœ†ğ‘¥. { L = ğ‘¥ âˆ’ 1 ; R = if ğ‘¥ < 0 then 0 else ğ‘¥ }
å¼•å…¥ ğ›½ ç±»å‹å˜é‡ä»£è¡¨ if è¡¨è¾¾å¼ç»“æœ
åœ¨ç±»å‹æ¨å¯¼(TI)æœŸé—´, ä¼šåŠ å…¥ä¸¤ä¸ªçº¦æŸ nat â‰¤ ğ›½ ä¸ ğ›¼ â‰¤ ğ›½ (å³ if çš„ä¸¤ä¸ªåˆ†æ”¯éƒ½ <: if è¡¨è¾¾å¼çš„ç»“æœ)
=> ğ›¼ âŠ“ int â†’ { L : int; R : ğ›½ },
æŠŠæ‰€æœ‰ positive ä½ç½®å‡ºç°çš„ ğ›½ æ›¿æ¢ä¸º  ğ›½âŠ”natâŠ”ğ›¼
=> ğ›¼ âŠ“ int â†’ { L : int; R : ğ›½ âŠ” nat âŠ” ğ›¼ }
ğ›½ æ˜¯å¤šä½™çš„è¿›è¡Œç®€åŒ–
=> ğ›¼ âŠ“ int â†’ { L : int; R : nat âŠ” ğ›¼ }

Java å…è®¸ä½¿ç”¨ç±»å‹å˜é‡æ¥ quantify ç±»å‹ï¼Œä¹Ÿå…è®¸ç”¨ subtypes å’Œ supertypes æ¥ bound è¿™äº›ç±»å‹å˜é‡ï¼Œ
unions ä¸ intersections åœ¨é€‚å½“ polarity ä½¿ç”¨æ—¶, åªæ˜¯ä¸€ç§é—´æ¥ bound ç±»å‹å˜é‡çš„æ–¹å¼
e.g. 1
ğ›¼ âŠ“ int â†’ { L : int; R : ğ›½ âŠ” nat âŠ” ğ›¼ }
ç­‰åŒäº (ç±»å‹å˜é‡è¾“åœ¨åœ¨<>ä¸­, | ä»£è¡¨ union), è¿™é‡Œæ˜¯ java çš„æ–¹è¨€, structurally-typed Java
âŸ¨ğ›¼ extends int, ğ›½ super nat | ğ›¼âŸ© (ğ›¼) â†’ { L : int; R : ğ›½ }
ğ›¼ æ˜¯ int çš„ subtype, ğ›½ åŒæ—¶æ˜¯ nat å’Œ ğ›¼ çš„ supertype
ç®€åŒ–å
ğ›¼ âŠ“ int â†’ { L : int; R : nat âŠ” ğ›¼ }
ç­‰åŒ
âŸ¨ğ›¼ super nat extends intâŸ© (ğ›¼) â†’ { L : int; R : ğ›¼ }
ç®€å•çš„ Intersection ç±»å‹ä¸ç®€å•çš„ bounded quantification æ˜¯å¯ä»¥äº’æ¢çš„
e.g. 2.
negative positive, subtypes (extends) ä¸ intersection äº’æ¢
class C {}
Bool f<T extends C>(T) { return true }
	f : <T <: C>. T -> Bool
ç­‰åŒäº
Bool f<T>(T & C) { return true }
	f : <T>. (T & C) -> Bool

------------------------------------------------------------------------------------
MLsubçš„ recursive type
------------------------------------------------------------------------------------

è‡³äºMLsubçš„ recursive typeï¼Œå¯ä»¥é€šè¿‡ F-bounded polymorphism æ¥è¡¨è¾¾ï¼ŒJava ä¹Ÿæ”¯æŒ(ç‹—å¤´)
F-bounded polymorphism å…è®¸ä¸€ä¸ªç±»å‹å˜é‡ ğ›¼ è¢«ä¸€ä¸ªåŒ…å« ğ›¼ æœ¬èº«çš„ç±»å‹è¡¨è¾¾å¼æ‰€çº¦æŸ(bound)ã€‚
e.g. <T extends F<T>>
å‚è€ƒï¼šhttps://zhuanlan.zhihu.com/p/60520184
public static <S extends Comparable> S min(S a, S b) {
    // ä¸¢å¤± compareTo æ–¹æ³•å‚æ•°ç±»å‹ä¿¡æ¯, å˜æˆ object, å¯ä»¥å†™å‡º
    a.compareTo(1)
}
F-bounded
public static <T extends Comparable<T>> T Fmin(T a, T b) {
    // ä¸ä¼šä¸¢å¤± compareTo æ–¹æ³•å‚æ•°ç±»å‹ä¿¡æ¯, å˜æˆ object
    a.compareTo(1) // error, éœ€è¦ T ç»™äº† int
}

intersections ç±»å‹å¯ä»¥ç”¨æ¥ç¼–ç ç±»å‹å˜é‡çš„ upper bounds
unions ç±»å‹å¯ä»¥ç”¨æ¥ç¼–ç ç±»å‹å˜é‡çš„ lower bounds
æŸç§æ„ä¹‰ä¸Š, ç”¨äº¤å¹¶é›†+ææ€§æ¥ç¼–ç ç±»å‹å˜é‡çš„ä¸Šä¸‹ç•Œæ˜¯ä»¥ä¸Š(äº¤é›†ç¼–ç ä¸Šç•Œ,å¹¶é›†ç¼–ç ä¸‹ç•Œ)åå‘çš„è½¬æ¢


------------------------------------------------------------------------------------
ä¸ºå•¥éœ€è¦é€’å½’ç±»å‹
------------------------------------------------------------------------------------
å› ä¸ºåœ¨ coalesce è¿‡ç¨‹ä¸­, ä¼šå‡ºç° "æ‰“ç»“", ç±»å‹å˜é‡å‡ºç°åœ¨è‡ªèº«çš„è¾¹ç•Œä¸­ï¼Œæ‰€ä»¥éœ€è¦åœ¨ user-facing ç±»å‹è¯­æ³•ä¸­ç”¨é€’å½’ç±»å‹æ¥å±•ç¤ºã€‚
e.g. s â†’ t where bounds s=(lower=nil, upper=nil) t=(lower=nil, upper=(s â†’ t)) , åˆ™ user-facing å±•ç¤º
FunctionType(
    TypeVariable("s"),
    RecursiveType("t",
        FunctionType(TypeVariable("s"), TypeVariable("t"))
    )
)
ğ›¼ â†’ (ğœ‡ğ›½.ğ›¼ â†’ ğ›½) åŒ–ç®€ä¸º âŠ¤ â†’ (ğœ‡ğ›¼.âŠ¤ â†’ ğ›¼))


------------------------------------------------------------------------------------
ç±»å‹ infer & coalesce ç¤ºä¾‹
------------------------------------------------------------------------------------
typeTerm(ğœ† ğ‘“ . ğœ†ğ‘¥. ğ‘“ (ğ‘“ ğ‘¥))(empty)
| typeTerm(ğœ†ğ‘¥. ğ‘“ (ğ‘“ ğ‘¥))(Map(ğ‘“ â†¦â†’ ğ›¼)) // ğ›¼ fresh
| | typeTerm(ğ‘“ (ğ‘“ ğ‘¥))(Map(ğ‘“ â†¦â†’ ğ›¼, ğ‘¥ â†¦â†’ ğ›½)) // ğ›½ fresh
| | | typeTerm(ğ‘“ )(Map(ğ‘“ â†¦â†’ ğ›¼, ğ‘¥ â†¦â†’ ğ›½)) = ğ›¼
| | | typeTerm(ğ‘“ ğ‘¥)(Map(ğ‘“ â†¦â†’ ğ›¼, ğ‘¥ â†¦â†’ ğ›½))
| | | | typeTerm(ğ‘“ )(Map(ğ‘“ â†¦â†’ ğ›¼, ğ‘¥ â†¦â†’ ğ›½)) = ğ›¼
| | | | typeTerm(ğ‘¥)(Map(ğ‘“ â†¦â†’ ğ›¼, ğ‘¥ â†¦â†’ ğ›½)) = ğ›½
| | | | constrain(ğ›¼, Function(ğ›½, ğ›¾)) // ğ›¾ fresh
| | | | | ğ›¼.upperBounds = Function(ğ›½, ğ›¾) :: ğ›¼.upperBounds
| | | = ğ›¾
| | | constrain(ğ›¼, Function(ğ›¾, ğ›¿)) // ğ›¿ fresh
| | | | ğ›¼.upperBounds = Function(ğ›¾, ğ›¿) :: ğ›¼.upperBounds
| | = ğ›¿
| = Function(ğ›½, ğ›¿)
= Function(ğ›¼, Function(ğ›½, ğ›¿))

ğ›¼ è¿™æ—¶æœ‰ä¸¤ä¸ªä¸Šç•Œ Function(ğ›½, ğ›¾), Function(ğ›¾,ğ›¿)
coalescing ç®—æ³•æŠŠæ¨å¯¼å‡ºçš„ SimpleType å±•å¼€æˆå±•ç¤ºç±»å‹

coalesceType(Function(ğ›¼, Function(ğ›½, ğ›¿)))
| do(Function(ğ›¼, Function(ğ›½, ğ›¿)), true)(empty)
| | do(ğ›¼, false)(empty)
| | | val bounds = Function(ğ›½, ğ›¾) :: Function(ğ›¾, ğ›¿) :: Nil
| | | val boundTypes
| | | | do(Function(ğ›½, ğ›¾), false)(Set(ğ›¼ â†¦â†’false)) = ğ›½ â†’ ğ›¾
| | | | do(Function(ğ›¾, ğ›¿), false)(Set(ğ›¼ â†¦â†’false)) = ğ›¾ â†’ ğ›¿
| | | = ğ›½ â†’ ğ›¾ :: ğ›¾ â†’ ğ›¿ :: Nil
| | = ğ›¼ âŠ“ (ğ›½ â†’ ğ›¾) âŠ“ (ğ›¾ â†’ ğ›¿)
| | do(Function(ğ›½, ğ›¿), true)(empty)
| | | do(ğ›½, false)(empty) = ğ›½
| | | do(ğ›¿, true)(empty) = ğ›¿
| | = ğ›½ â†’ ğ›¿
| = ğ›¼ âŠ“ (ğ›½ â†’ ğ›¾) âŠ“ (ğ›¾ â†’ ğ›¿) â†’ ğ›½ â†’ ğ›¿
= ğ›¼ âŠ“ (ğ›½ â†’ ğ›¾) âŠ“ (ğ›¾ â†’ ğ›¿) â†’ ğ›½ â†’ ğ›¿
ç®€åŒ– ğ›¼ âŠ“ (ğ›½ âŠ”ğ›¾ â†’ ğ›¾ âŠ“ ğ›¿) â†’ ğ›½ â†’ ğ›¿, ğ›¼ åªå‡ºç°åœ¨ negative ä½ç½®, ğ›¿ and ğ›¾ co-occur negative, å¯ä»¥åˆå¹¶
ç®€åŒ– (ğ›½ âŠ”ğ›¾ â†’ ğ›¾) â†’ ğ›½ â†’ ğ›¾

------------------------------------------------------------------------------------
let å¤šæ€ä¸é€’å½’
------------------------------------------------------------------------------------
let å¤šæ€
ä¼ ç»Ÿçš„MLè¯­è¨€ä¸­ï¼Œåªæœ‰å±€éƒ¨ let ç»‘å®šæ‰å¯ä»¥äº§ç”Ÿå¤šæ€ç±»å‹ã€‚
éœ€è¦è·Ÿè¸ª generalized typing schemeï¼Œè¿™äº› typing scheme åœ¨ let body ä¸­æ¯æ¬¡å‡ºç°ï¼Œéƒ½éœ€è¦ä½¿ç”¨ fresh variable è¿›è¡Œ instantiatedï¼Œ
å¹¶ç¡®ä¿ä¸èƒ½ generalized ç¯å¢ƒä¸­å­˜åœ¨çš„ç±»å‹å˜é‡ï¼Œå¦åˆ™ unsoundã€‚
let y = 1
let f = x -> (x, y) in f(1);f("s")
æ³›åŒ– (x, y) æ—¶ä¸èƒ½æ³›åŒ– y, y çš„ level æ¯”å½“å‰ x çš„ rhs çš„ level ä½

One way of determining which type variables to generalize is to scan the current environment,
looking for references to the type variables in question. However, that is quite inefficient (it adds a
linear-time operation in an important part of the algorithm).

Efficient generalization in ML. A better approach is to use levels. The idea is that all fresh type
variables created inside the right-hand side of a let binding are first assigned a higher level, which
indicates that they should be generalized. However, the level of a variable is lowered when the
variable â€œescapesâ€ through a constraint into the enclosing environment, preventing its future generalization.

ä½ level çš„ç±»å‹å˜é‡æ°¸è¿œä¸ä¼šé€šè¿‡è¾¹ç•Œå¼•ç”¨é«˜ level ç±»å‹å˜é‡, å¿…è¦æ—¶å¤åˆ¶ç±»å‹ç»“æ„ä¿è¯

Simple-sub typing with levels. We can use the same idea to achieve let polymorphism in Simplesub,
though we have to be a little more careful, because we do not merely unify type variables as in
ML, but instead we constrain their bounds. Our idea is to make sure that lower-level type variables
never refer to higher-level ones through their bounds, and to enforce that property by duplicating
type structures as needed, when it would otherwise be violated by the addition of a bound.